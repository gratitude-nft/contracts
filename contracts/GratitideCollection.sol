// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Math/SafeMath.sol";

import "./ERC721Base.sol";

contract GratitideCollection is ERC721Base, ReentrancyGuard {
  using SafeMath for uint256;

  //maximum amount that can be purchased at a time
  uint8 public constant MAX_PURCHASE = 5;
  //start date of the token sale
  uint64 public constant START_DATE = 1642291200;
  //the sale price per token
  uint256 public constant SALE_PRICE = 0.8 ether;

  mapping(uint256 => string) private _cids;

  /**
   * @dev Grants `DEFAULT_ADMIN_ROLE` and `PAUSER_ROLE` to the
   * account that deploys the contract. Sets the contract's URI. 
   * Sets the max supply and reveal date
   */
  constructor(string memory uri) ERC721Base(
    //name
    "Gratitide Collection",
    //symbol 
    "GRATITUDE",
    //max supply 
    10000, 
    //contract uri
    uri
  ) {}

  /**
   * @dev Creates a new token for `to`. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   */
  function mint(uint256 quantity) external payable nonReentrant {
    //has the sale started?
    require(uint64(block.timestamp) >= START_DATE, "Sale has not started");

    //fix for valid quantity
    if (quantity == 0) {
      quantity = 1;
    }

    //call once, use multiple times...
    address sender = _msgSender();

    //the quantity here plus the current balance 
    //should be less than the max purchase amount
    require(
      quantity.add(balanceOf(sender)) <= MAX_PURCHASE, 
      "Cannot mint more than allowed"
    );
    //the value sent should be the price times quantity
    require(
      quantity.mul(SALE_PRICE) <= msg.value, 
      "Amount sent is not correct"
    );
    //the quantity being minted should not exceed the max supply
    require(
      totalSupply().add(quantity) <= MAX_SUPPLY, 
      "Amount exceeds total allowable collection"
    );

    //loop through quantity and mint
    for(uint i = 0; i < quantity; i++) {
      _mint(sender);
    }
  }

  /**
   * @dev Since we are using IPFS CID for the token URI, we can allow 
   * the changing of the base URI to toggle between services for faster 
   * speeds while keeping the metadata provably fair
   */
  function setBaseTokenURI(string memory uri) 
    external virtual onlyRole(CURATOR_ROLE) 
  {
    _setBaseTokenURI(uri);
  }

  /**
   * @dev Instead of set toke URI, we set the IPFS CID. This will 
   * allow the contract to toggle between services for faster speeds
   * while keeping the metadata provably fair
   */
  function setTokenCID(uint256 tokenId, string memory cid) 
    external virtual onlyRole(CURATOR_ROLE) 
  {
    require(bytes(_cids[tokenId]).length == 0, "CID already set for token");
    _cids[tokenId] = cid;
  }

  /**
   * @dev Combines the base token URI and the token CID to form a full 
   * token URI
   */
  function tokenURI(uint256 tokenId) public view virtual override returns(string memory) {
    require(_exists(tokenId), "URI query for nonexistent token");
    require(bytes(_cids[tokenId]).length > 0, "URI not set yet for token");
    return string(abi.encodePacked(baseTokenURI(), _cids[tokenId]));
  }
}
