// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "./ERC721Base.sol";

contract GratitideCollection is ERC721Base, ReentrancyGuard {
  using Strings for uint256;
  using SafeMath for uint256;

  // ============ Constants ============

  //maximum amount that can be purchased at a time
  uint8 public constant MAX_PURCHASE = 5;
  //start date of the token sale
  //Feb 13, 2022 20:22:00 GTM
  //uint64 public constant PRESALE_DATE = 1644710400;
  uint64 public constant PRESALE_DATE = 1;
  //Feb 22, 2022 20:22:00 GTM
  //uint64 public constant SALE_DATE = 1645561320;
  uint64 public constant SALE_DATE = 1;
  //the sale price per token
  uint256 public constant SALE_PRICE = 0.05 ether;
  //the provenance hash (the CID)
  string public PROVENANCE;
  //the offset to be used to determine what token id should get which CID
  uint16 public indexOffset;
  //mapping of token id to custom uri
  mapping(uint256 => string) public customURI;
  //mapping of ambassador address to whether if they redeemed already
  mapping(address => bool) public ambassadors;

  // ============ Deploy ============

  /**
   * @dev Sets up ERC721Base. Permanently sets the IPFS CID
   */
  constructor(
    string memory uri, 
    string memory cid
  ) ERC721Base(
    //name
    "Gratitide Collection",
    //symbol 
    "GRATITUDE",
    //max supply
    2222
  ) {
    //make cid immutable
    PROVENANCE = cid;
    //set the initial base uri
    _setBaseTokenURI(uri);
  }

  // ============ Read Methods ============

  /**
   * @dev The URI for contract data ex. https://creatures-api.opensea.io/contract/opensea-creatures
   * Example Format:
   * {
   *   "name": "OpenSea Creatures",
   *   "description": "OpenSea Creatures are adorable aquatic beings primarily for demonstrating what can be done using the OpenSea platform. Adopt one today to try out all the OpenSea buying, selling, and bidding feature set.",
   *   "image": "https://openseacreatures.io/image.png",
   *   "external_link": "https://openseacreatures.io",
   *   "seller_fee_basis_points": 100, # Indicates a 1% seller fee.
   *   "fee_recipient": "0xA97F337c39cccE66adfeCB2BF99C1DdC54C2D721" # Where seller fees will be paid to.
   * }
   */
  function contractURI() public view returns (string memory) {
    //ex. https://ipfs.io/ipfs/ + Qm123abc + /contract.json
    return string(
      abi.encodePacked(baseTokenURI(), PROVENANCE, "/contract.json")
    );
  }

  /**
   * @dev Combines the base token URI and the token CID to form a full 
   * token URI
   */
  function tokenURI(uint256 tokenId) 
    public view virtual override returns(string memory) 
  {
    require(_exists(tokenId), "URI query for nonexistent token");
    
    //if there is a custom URI
    if (bytes(customURI[tokenId]).length > 0) {
      //return that
      return customURI[tokenId];
    }

    //if no offset
    if (indexOffset == 0) {
      //use the placeholder
      return string(
        abi.encodePacked(baseTokenURI(), PROVENANCE, "/placeholder.json")
      );
    }

    //for example, given offset is 2 and size is 8:
    // - token 5 = ((5 + 2) % 8) + 1 = 8
    // - token 6 = ((6 + 2) % 8) + 1 = 1
    // - token 7 = ((7 + 2) % 8) + 1 = 2
    // - token 8 = ((8 + 2) % 8) + 1 = 3
    uint256 index = tokenId.add(indexOffset).mod(MAX_SUPPLY).add(1);
    //ex. https://ipfs.io/ + Qm123abc + / + 1000 + .json
    return string(
      abi.encodePacked(baseTokenURI(), PROVENANCE, "/", index.toString(), ".json")
    );
  }

  // ============ Minting Methods ============

  /**
   * @dev Allows anyone to get a token that was approved by a 
   * `MINTER_ROLE`
   */
  function authorize(uint256 quantity, bytes memory proof) 
    external payable nonReentrant 
  {
    //has the sale started?
    require(
      uint64(block.timestamp) >= PRESALE_DATE, 
      "Presale has not started"
    );

    address recipient = _msgSender();

    //make sure the minter signed this off
    require(hasRole(MINTER_ROLE, ECDSA.recover(
      ECDSA.toEthSignedMessageHash(
        keccak256(abi.encodePacked("authorized", recipient))
      ),
      proof
    )), "Invalid proof.");
    //now purchase token
    _buy(quantity, recipient);
  }

  /**
   * @dev Creates a new token for the sender. Its token ID will be 
   * automatically assigned (and available on the emitted 
   * {IERC721-Transfer} event), and the token URI autogenerated based 
   * on the base URI passed at construction.
   */
  function mint(uint256 quantity) external payable nonReentrant {
    //has the sale started?
    require(uint64(block.timestamp) >= SALE_DATE, "Sale has not started");
    //now purchase token
    _buy(quantity, _msgSender());
  }

  /**
   * @dev Allows an ambassador to redeem their tokens
   */
  function redeem(string memory uri, bool ambassador, bytes memory proof) 
    external virtual 
  {
    address recipient = _msgSender();
    //check to see if they redeemed already
    require(ambassadors[recipient] == false, "Already redeemed");

    //make sure the minter signed this off
    require(hasRole(MINTER_ROLE, ECDSA.recover(
      ECDSA.toEthSignedMessageHash(
        keccak256(abi.encodePacked("redeemable", uri, recipient, ambassador))
      ),
      proof
    )), "Invalid proof.");

    //mint token
    _safeMint(recipient);
    //add custom uri, so we know what token to customize
    customURI[lastId()] = uri;
    //flag that an ambassador has redeemed
    ambassadors[recipient] = true;
    //if they are apart of the founding team
    if (!ambassador) {
      //mint 3 for them too
      for(uint i = 0; i < 3; i++) {
        _safeMint(recipient);
      }
    }
  }

  /**
   * @dev Allows the proceeds to be withdrawn
   */
  function withdraw() external virtual onlyRole(DEFAULT_ADMIN_ROLE) {
    //set the offset
    indexOffset = uint16(block.number - 1) % MAX_SUPPLY;
    if (indexOffset == 0) {
      indexOffset = 1;
    }

    uint balance = address(this).balance;
    payable(_msgSender()).transfer(balance);
  }

  /**
   * @dev Purchases tokens
   */
  function _buy(uint256 quantity, address recipient) internal virtual {
    //make sure recipient is a valid address
    require(recipient != address(0), "Invalid recipient");
    //fix for valid quantity
    if (quantity == 0) {
      quantity = 1;
    }

    //the quantity here plus the current balance 
    //should be less than the max purchase amount
    require(
      quantity.add(balanceOf(recipient)) <= MAX_PURCHASE, 
      "Cannot mint more than allowed"
    );
    //the value sent should be the price times quantity
    require(
      quantity.mul(SALE_PRICE) <= msg.value, 
      "Amount sent is not correct"
    );
    //the quantity being minted should not exceed the max supply
    require(
      totalSupply().add(quantity) <= MAX_SUPPLY, 
      "Amount exceeds total allowable collection"
    );

    //loop through quantity and mint
    for(uint i = 0; i < quantity; i++) {
      _safeMint(recipient);
    }
  }

  // ============ Metadata Methods ============

  /**
   * @dev Since we are using IPFS CID for the token URI, we can allow 
   * the changing of the base URI to toggle between services for faster 
   * speeds while keeping the metadata provably fair
   */
  function setBaseTokenURI(string memory uri) 
    external virtual onlyRole(CURATOR_ROLE) 
  {
    _setBaseTokenURI(uri);
  }
}