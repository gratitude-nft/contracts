// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Math/SafeMath.sol";

import "./GratitideCollection.sol";

contract GratitudeSale is ReentrancyGuard, GratitideCollection {
  using SafeMath for uint256;
  
  uint8 public constant MAX_PURCHASE = 5;
  uint16 public constant TOTAL_COLLECTION = 10000;
  uint64 public constant START_DATE = 1642291200;
  uint64 public constant REVEAL_DATE = 1642291200;
  uint256 public constant SALE_PRICE = 0.8 ether;

  constructor(string memory contractURI) GratitideCollection(
    "Gratitide Collection", 
    "GRATITUDE", 
    contractURI
  ) {}

  /**
   * @dev Creates a new token for `to`. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   */
  function mint(uint256 amount) external payable nonReentrant {
    require(uint64(block.timestamp) >= START_DATE, "Sale has not started");
    require(uint64(block.timestamp) < REVEAL_DATE, "Minting disabled");
    require(amount.mul(SALE_PRICE) <= msg.value, "Amount sent is not correct");

    if (amount == 0) {
      amount += 1;
    }

    require(amount <= MAX_PURCHASE, "Cannot mint more than allowed");
    require(
      totalSupply().add(amount) <= TOTAL_COLLECTION, 
      "Amount exceeds total allowable collection"
    );

    for(uint i = 0; i < amount; i++) {
      _mint(_msgSender());
    }
  }
}